"use strict";
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
Object.defineProperty(exports, "__esModule", { value: true });
exports.countsReducer = exports.threadsInTeamReducer = exports.threadsReducer = void 0;
var tslib_1 = require("tslib");
var action_types_1 = require("../../action_types");
var redux_1 = require("redux");
var threadsReducer = function (state, action) {
    var _a, _b;
    if (state === void 0) { state = {}; }
    switch (action.type) {
        case action_types_1.ThreadTypes.RECEIVED_THREADS: {
            var threads = action.data.threads;
            return tslib_1.__assign(tslib_1.__assign({}, state), threads.reduce(function (results, thread) {
                results[thread.id] = thread;
                return results;
            }, {}));
        }
        case action_types_1.ThreadTypes.RECEIVED_THREAD: {
            var thread = action.data.thread;
            return tslib_1.__assign(tslib_1.__assign({}, state), (_a = {}, _a[thread.id] = thread, _a));
        }
        case action_types_1.ThreadTypes.FOLLOW_CHANGED_THREAD: {
            var _c = action.data, id = _c.id, following = _c.following;
            return tslib_1.__assign(tslib_1.__assign({}, state), (_b = {}, _b[id] = tslib_1.__assign(tslib_1.__assign({}, (state[id] || {})), { is_following: following }), _b));
        }
        case action_types_1.UserTypes.LOGOUT_SUCCESS:
            return {};
    }
    return state;
};
exports.threadsReducer = threadsReducer;
var threadsInTeamReducer = function (state, action) {
    var _a, _b;
    var _c;
    if (state === void 0) { state = {}; }
    switch (action.type) {
        case action_types_1.ThreadTypes.RECEIVED_THREADS: {
            var nextSet_1 = new Set(state[action.data.team_id]);
            action.data.threads.forEach(function (thread) {
                nextSet_1.add(thread.id);
            });
            return tslib_1.__assign(tslib_1.__assign({}, state), (_a = {}, _a[action.data.team_id] = tslib_1.__spread(nextSet_1), _a));
        }
        case action_types_1.ThreadTypes.RECEIVED_THREAD: {
            if ((_c = state[action.data.team_id]) === null || _c === void 0 ? void 0 : _c.includes(action.data.thread.id)) {
                return state;
            }
            var nextSet = new Set(state[action.data.team_id]);
            nextSet.add(action.data.thread.id);
            return tslib_1.__assign(tslib_1.__assign({}, state), (_b = {}, _b[action.data.team_id] = tslib_1.__spread(nextSet), _b));
        }
        case action_types_1.TeamTypes.LEAVE_TEAM: {
            var team = action.data;
            if (!state[team.id]) {
                return state;
            }
            var nextState = tslib_1.__assign({}, state);
            Reflect.deleteProperty(nextState, team.id);
            return nextState;
        }
        case action_types_1.UserTypes.LOGOUT_SUCCESS:
            return {};
    }
    return state;
};
exports.threadsInTeamReducer = threadsInTeamReducer;
var countsReducer = function (state, action) {
    var _a, _b;
    var _c, _d, _e;
    if (state === void 0) { state = {}; }
    switch (action.type) {
        case action_types_1.ThreadTypes.RECEIVED_PER_CHANNEL_MENTION_COUNTS: {
            return tslib_1.__assign(tslib_1.__assign({}, state), (_a = {}, _a[action.data.team_id] = tslib_1.__assign(tslib_1.__assign({}, (_c = state[action.data.team_id]) !== null && _c !== void 0 ? _c : {}), { unread_mentions_per_channel: action.data.counts }), _a));
        }
        case action_types_1.ThreadTypes.RECEIVED_THREADS: {
            return tslib_1.__assign(tslib_1.__assign({}, state), (_b = {}, _b[action.data.team_id] = {
                unread_mentions_per_channel: (_e = (_d = state[action.data.team_id]) === null || _d === void 0 ? void 0 : _d.unread_mentions_per_channel) !== null && _e !== void 0 ? _e : {},
                total: action.data.total,
                total_unread_threads: action.data.total_unread_threads,
                total_unread_mentions: action.data.total_unread_mentions,
            }, _b));
        }
        case action_types_1.TeamTypes.LEAVE_TEAM: {
            var team = action.data;
            if (!state[team.id]) {
                return state;
            }
            var nextState = tslib_1.__assign({}, state);
            Reflect.deleteProperty(nextState, team.id);
            return nextState;
        }
        case action_types_1.UserTypes.LOGOUT_SUCCESS:
            return {
                total: 0,
                unread_mentions_per_channel: {},
                total_unread_threads: 0,
                total_unread_mentions: 0,
            };
    }
    return state;
};
exports.countsReducer = countsReducer;
exports.default = redux_1.combineReducers({
    threads: exports.threadsReducer,
    threadsInTeam: exports.threadsInTeamReducer,
    counts: exports.countsReducer,
});
//# sourceMappingURL=threads.js.map